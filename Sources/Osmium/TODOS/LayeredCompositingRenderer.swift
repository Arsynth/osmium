//
// Created by Artem Sechko on 17.06.2021.
//

import Foundation

class LayeredCompositingRenderer {
/*
Можно виртуально разбить композицию на сетку, а ее использовать как атлас при сборке в компьют шейдере.
Для самого начала(для простоты) в каждой ячейке отрисовывается один слой. Каждый слой имеет номер своей ячейки.
Каждая виртуальная ячейка шарит одинаковое смещение геометрии по x и y со своими соседями, чтобы вычитать это смещение из просчитанных
вертексов для дальнейшей эмуляции clipping rect(к этому моменту они уже были помножены на все возможные матрицы)
и прибавлять это смещение к ячейке при композиции в компьютер шейдере.
Основная идея в том, что подход строго ограничивает только область композиции, заставляя иерархию
перерисовываться полностью за каждый тайл, но метод не ограничивает композицию в глубину.
От глубины зависит количество тайлов. От количества тайлов зависит количество перерисовок.
Благодаря этому способу известны значения пикселей всех слоев в одной clipping зоне.
Таким образом компьют шейдеру можно передавать массив инструкций для композитинга.
Скорее всего инструкция будет содержать только 2 индекса - source tile и destination tile.
Массив инструкций можно переиспользовать между отрисовками всей сцены и пересчитывать нужно только в том случае,
когда изменится иерархия слоёв. Пожалуй, самым сложным будет рассчитать массив инструкций, но реализуемым.
Групповая прозрачность требует наличие информации о цвете сразу всех слоев, что не позволяет использовать
константное количество текстур.

По сравнению с существующей реализацией:
- Не создается дополнительных рендер пассов на каждый композитный слой
- Нет нужды в использовании кучи. Вместо нее будет использоваться одна текстура, виртуально разбитая на тайлы
статичного размера
- Не нужно рассчитывать размер текстуры для каждого композитного слоя, чтобы он не клиппил подслои
- Скорее всего можно будет распараллелить рендер энкодеры для нескольких слоёв
- Больше разбега для оптимизации. Например, в зависимости от размера и поворота слоя можно активировать определенное количество
тредов в MTLComputeCommandEncoder
- К этому же подходу можно будет применить оптимизацию расхода текстур, как в существующем, только уже для быстродействия
- Можно будет переписать под IndirectCommandBuffer'ы

Нужно внимательнее посмотреть, как использовать scissorRect - https://developer.apple.com/documentation/metal/mtlrendercommandencoder/2869722-setscissorrects
Узнать, можно ли использовать его для инстансинга. Инстансинг может серьезно сократить количество вызовов энкодера

С чем имеем дело:
- Текстура, разбитая на тайлы, каждый из которых отвечает за один слой. Во все эти ячейки отрисовываются слои с одинаковым смещением
- Финальный рендер таргет. В него рисует уже компьют энкодер. После отрисовки во все ячейки компьют энкодер получает
текстуру с тайлами и смещение в рендер таргете и начинает собирать туда тайлы(пока что циклом), то есть один тред
натравливается на один пиксель рендер таргета, циклом перечисляет все тайлы и берет из них соответствующий пиксель.
tilePixelCoord = renderTargetCoord - tileOffset

*/
}
